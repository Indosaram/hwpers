use hwpers::{HwpReader, HwpWriter};

#[test]
fn test_basic_writer_creation() {
    let writer = HwpWriter::new();
    assert!(writer.to_bytes().is_ok());
}

#[test]
fn test_add_single_paragraph() {
    let mut writer = HwpWriter::new();
    assert!(writer.add_paragraph("안녕하세요").is_ok());
    assert!(writer.to_bytes().is_ok());
}

#[test]
fn test_add_multiple_paragraphs() {
    let mut writer = HwpWriter::new();
    assert!(writer.add_paragraph("첫 번째 문단").is_ok());
    assert!(writer.add_paragraph("두 번째 문단").is_ok());
    assert!(writer.add_paragraph("세 번째 문단").is_ok());
    assert!(writer.to_bytes().is_ok());
}

#[test]
fn test_save_to_file() {
    let mut writer = HwpWriter::new();
    writer.add_paragraph("테스트 문서").unwrap();

    let temp_path = "test_output.hwp";
    assert!(writer.save_to_file(temp_path).is_ok());

    // Clean up
    if std::path::Path::new(temp_path).exists() {
        std::fs::remove_file(temp_path).ok();
    }
}

#[test]
fn test_write_read_roundtrip() {
    let mut writer = HwpWriter::new();
    writer.add_paragraph("Hello World").unwrap();
    writer.add_paragraph("안녕하세요").unwrap();

    let bytes = writer.to_bytes().unwrap();
    assert!(!bytes.is_empty());

    // Try to parse the generated bytes with HwpReader
    // Note: This might fail initially as our CFB generation is simplified
    let parse_result = HwpReader::from_bytes(&bytes);

    // For now, we just verify that the writer produces some output
    // In the future, we can verify the reader can parse it correctly
    println!("Generated {} bytes", bytes.len());
    println!("Reader parse result: {:?}", parse_result.is_ok());
}

#[test]
fn test_empty_document() {
    let writer = HwpWriter::new();
    let bytes = writer.to_bytes().unwrap();
    assert!(!bytes.is_empty());
    println!("Empty document size: {} bytes", bytes.len());
}

#[test]
fn test_korean_text() {
    let mut writer = HwpWriter::new();
    writer.add_paragraph("한글 문서 테스트").unwrap();
    writer.add_paragraph("韓國語 漢字 混用").unwrap();
    writer.add_paragraph("English mixed text").unwrap();

    let bytes = writer.to_bytes().unwrap();
    assert!(!bytes.is_empty());
    println!("Mixed language document size: {} bytes", bytes.len());
}
